// src/pages/DashboardPage.tsx
import { useEffect, useState, useCallback } from 'react';
import { getEmails, sendEmail, checkAvailability, createCalendarEvent } from '../api/emailApi';
import DOMPurify from 'dompurify';
import { Mail, Loader, AlertCircle, Send, CalendarPlus, CheckCircle, XCircle, LogOut, Calendar as CalendarIcon } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Textarea } from "@/components/ui/textarea";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Separator } from "@/components/ui/separator";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Calendar } from "@/components/ui/calendar";
import { format } from "date-fns";

// --- FINAL TYPE DEFINITION ---
interface AnalyzedEmail {
  _id: string;
  from: string;
  subject: string;
  snippet: string;
  receivedAt: string;
  aiPriority: 'urgent' | 'neutral' | 'spam' | 'error';
  body?: string;
  aiSummary?: string;
  aiSuggestion?: string;
  isMeetingRequest?: boolean;
  aiProposedDate?: string | null;
  aiProposedTime?: string | null;
  gmailMessageId: string;
  threadId: string;
  messageIdHeader?: string;
  referencesHeader?: string;
}

interface UserInfo {
  name: string;
  email: string;
}

// --- SUB-COMPONENTS ---

const PriorityBadge = ({ priority }: { priority: AnalyzedEmail['aiPriority'] }) => {
  const variantMap: Record<string, 'destructive' | 'default' | 'secondary' | 'outline'> = { 
    urgent: 'destructive', 
    neutral: 'default', 
    spam: 'secondary', 
    error: 'outline',
  };
  const text = priority === 'error' ? 'AI Error' : priority;
  return <Badge variant={variantMap[priority]} className="capitalize">{text}</Badge>;
};

const CalendarAssistant = ({ email }: { email: AnalyzedEmail }) => {
  const getInitialDateFromAI = () => {
    if (email.aiProposedDate) {
      const safeDateString = `${email.aiProposedDate}T12:00:00`;
      const parsedDate = new Date(safeDateString);
      if (!isNaN(parsedDate.getTime())) {
        return parsedDate;
      }
    }
    return new Date();
  };

  const [date, setDate] = useState<Date | undefined>(getInitialDateFromAI());
  const [time, setTime] = useState(email.aiProposedTime || "10:00");
  const [availability, setAvailability] = useState<{ isAvailable: boolean } | null>(null);
  const [isChecking, setIsChecking] = useState(false);
  const [isScheduling, setIsScheduling] = useState(false);

  const handleCheckAvailability = useCallback(async () => {
    if (!date) return;
    setIsChecking(true);
    setAvailability(null);
    const [hours, minutes] = time.split(':').map(Number);
    const startDateTime = new Date(date);
    startDateTime.setHours(hours, minutes, 0, 0);
    const endDateTime = new Date(startDateTime.getTime() + 30 * 60000); // 30 minute meeting
    try {
      const result = await checkAvailability(startDateTime.toISOString(), endDateTime.toISOString());
      setAvailability(result);
    } catch (error) {
      alert("Failed to check availability.");
    } finally {
      setIsChecking(false);
    }
  }, [date, time]);

  const handleScheduleEvent = async () => {
    if (!date || !availability?.isAvailable) return;
    setIsScheduling(true);
    const [hours, minutes] = time.split(':').map(Number);
    const startDateTime = new Date(date);
    startDateTime.setHours(hours, minutes, 0, 0);
    const endDateTime = new Date(startDateTime.getTime() + 30 * 60000);
    const emailRegex = /<(.+)>/;
    const match = email.from.match(emailRegex);
    const attendeeEmail = match ? match[1] : email.from;

    const eventData = {
      summary: `Meeting: ${email.subject}`,
      description: `Generated by AI Email Workflow Tool.\n\nOriginal email snippet:\n${email.snippet}`,
      start: startDateTime.toISOString(),
      end: endDateTime.toISOString(),
      attendees: [attendeeEmail],
    };

    try {
      await createCalendarEvent(eventData);
      alert('Event scheduled successfully!');
    } catch (error) {
      alert('Failed to schedule event.');
    } finally {
      setIsScheduling(false);
    }
  };

  return (
    <Card className="mt-4 bg-blue-50 border-blue-200">
      <CardHeader><CardTitle className="text-lg flex items-center"><CalendarPlus className="mr-2 h-5 w-5" /> Schedule Meeting</CardTitle></CardHeader>
      <CardContent className="space-y-4">
        <p className="text-sm text-muted-foreground">AI has detected a meeting request. Propose a time:</p>
        <div className="flex flex-wrap items-center gap-2">
            <Popover>
                <PopoverTrigger asChild><Button variant="outline">{date ? format(date, "PPP") : <span>Pick a date</span>}</Button></PopoverTrigger>
                <PopoverContent className="w-auto p-0"><Calendar mode="single" selected={date} onSelect={setDate} initialFocus /></PopoverContent>
            </Popover>
            <input type="time" value={time} onChange={(e) => setTime(e.target.value)} className="p-2 border rounded-md text-sm" />
            <Button onClick={handleCheckAvailability} disabled={isChecking}>{isChecking ? <Loader className="h-4 w-4 animate-spin"/> : "Check"}</Button>
        </div>
        {availability !== null && (
            <p className={`text-sm font-semibold flex items-center ${availability.isAvailable ? 'text-green-600' : 'text-red-600'}`}>
                {availability.isAvailable ? <CheckCircle className="h-4 w-4 mr-2" /> : <XCircle className="h-4 w-4 mr-2" />}
                {availability.isAvailable ? "This time slot is available!" : "Conflict found. Choose another time."}
            </p>
        )}
        <Button onClick={handleScheduleEvent} disabled={!availability?.isAvailable || isScheduling}>
            {isScheduling ? <Loader className="mr-2 h-4 w-4 animate-spin" /> : null}
            Schedule Event & Send Invite
        </Button>
      </CardContent>
    </Card>
  );
};

const UserProfileCard = ({ user, onLogout }: { user: UserInfo, onLogout: () => void }) => {
  return (
    <div className="p-4 border-t shrink-0">
      <div className="flex items-center space-x-3">
        <Avatar><AvatarFallback>{user.name.charAt(0).toUpperCase()}</AvatarFallback></Avatar>
        <div className="flex-1 min-w-0">
          <p className="font-semibold truncate">{user.name}</p>
          <p className="text-sm text-muted-foreground truncate">{user.email}</p>
        </div>
        <Button variant="ghost" size="icon" onClick={onLogout} aria-label="Log out"><LogOut className="h-5 w-5" /></Button>
      </div>
    </div>
  );
};

// --- FINAL MAIN DASHBOARD COMPONENT ---
export function DashboardPage() {
  const [emails, setEmails] = useState<AnalyzedEmail[]>([]);
  const [selectedEmailId, setSelectedEmailId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [replyContent, setReplyContent] = useState('');
  const [isSending, setIsSending] = useState(false);
  const [activeFilter, setActiveFilter] = useState<'all' | 'urgent' | 'neutral' | 'spam'>('all');
  const [user, setUser] = useState<UserInfo | null>(null);
  
  const selectedEmail = emails.find(e => e.gmailMessageId === selectedEmailId) || null;

  const handleLogout = useCallback(() => {
    localStorage.clear();
    window.location.href = '/login';
  }, []);

  // Simplified logic: Just set the ID. All analysis is done on load.
  const handleSelectEmail = (email: AnalyzedEmail) => {
    setSelectedEmailId(email.gmailMessageId);
  };

  useEffect(() => {
    const initialize = async () => {
      setIsLoading(true);
      const params = new URLSearchParams(window.location.search);
      const token = params.get('token');
      if (token) {
        localStorage.setItem('authToken', token);
        const name = decodeURIComponent(params.get('name') || '');
        const email = decodeURIComponent(params.get('email') || '');
        if (name && email) {
          localStorage.setItem('userName', name);
          localStorage.setItem('userEmail', email);
          setUser({ name, email });
        }
        window.history.replaceState({}, document.title, "/dashboard");
      } else {
        const storedName = localStorage.getItem('userName');
        const storedEmail = localStorage.getItem('userEmail');
        if (storedName && storedEmail) {
          setUser({ name: storedName, email: storedEmail });
        } else {
          handleLogout();
          return;
        }
      }

      try {
        const emailListData = await getEmails();
        setEmails(emailListData);
      } catch (err: any) { 
        if (err.response && err.response.status === 401) {
          handleLogout();
        } else {
          setError(err.message || 'Failed to fetch emails.');
        }
      } finally { 
        setIsLoading(false); 
      }
    };
    initialize();
  }, [handleLogout]);

  useEffect(() => {
    if (selectedEmail) {
      setReplyContent(selectedEmail.aiSuggestion || '');
    } else {
      setReplyContent('');
    }
  }, [selectedEmail]);

  const handleSendEmail = async () => {
    if (!selectedEmail) return;
    setIsSending(true);
    try {
      const emailRegex = /<(.+)>/;
      const match = selectedEmail.from.match(emailRegex);
      const toEmail = match ? match[1] : selectedEmail.from;
      await sendEmail({
        to: toEmail,
        subject: `Re: ${selectedEmail.subject}`,
        body: replyContent,
        threadId: selectedEmail.threadId,
        inReplyTo: selectedEmail.messageIdHeader!,
        references: selectedEmail.referencesHeader || selectedEmail.messageIdHeader!,
      });
      alert('Reply sent successfully!');
    } catch (error) { 
      console.error("Send Email Error:", error);
      alert('Failed to send reply. Check console for details.');
    } finally { 
      setIsSending(false); 
    }
  };

  const filteredEmails = emails.filter(email => {
    if (activeFilter === 'all') return true;
    return email.aiPriority === activeFilter;
  });
  
  const emailCounts = emails.reduce((acc, e) => {
    acc.all++;
    if (e.aiPriority === 'urgent') acc.urgent++;
    else if (e.aiPriority === 'spam') acc.spam++;
    else acc.neutral++; // This counts 'neutral' and 'error'
    return acc;
  }, { all: 0, urgent: 0, neutral: 0, spam: 0 });

  if (isLoading) return <div className="flex h-screen w-screen items-center justify-center"><Loader className="h-8 w-8 animate-spin" /> <p className="ml-4 text-lg">Loading & Analyzing Inbox...</p></div>;
  if (error) return <div className="flex h-screen w-screen items-center justify-center text-red-600"><AlertCircle className="h-8 w-8 mr-4" /> <p className="text-lg">Error: {error}</p></div>;

  return (
    <div className="h-screen w-screen flex flex-col bg-slate-50">
      <header className="p-4 border-b flex items-center justify-between bg-background z-10 shrink-0">
        <h1 className="text-2xl font-bold flex items-center"><Mail className="mr-3 h-7 w-7 text-primary"/> AI Inbox</h1>
        <div className="flex items-center space-x-2">
            <Button variant="outline" size="sm" onClick={() => window.open('https://calendar.google.com', '_blank')}><CalendarIcon className="mr-2 h-4 w-4"/> Open Calendar</Button>
            <Separator orientation="vertical" className="h-6 mx-2" />
            {(['all', 'urgent', 'neutral', 'spam'] as const).map(filter => (
              <Button key={filter} onClick={() => setActiveFilter(filter)} variant={activeFilter === filter ? 'default' : 'secondary'} size="sm" className="capitalize">
                {filter} <Badge variant="outline" className="ml-2">{emailCounts[filter]}</Badge>
              </Button>
            ))}
        </div>
      </header>
      <div className="flex flex-1 overflow-hidden">
        <aside className="w-[450px] border-r bg-background flex flex-col shrink-0">
          <div className="overflow-y-auto flex-grow">
              <div className="divide-y">
                {filteredEmails.map((email: AnalyzedEmail) => (
                  <div key={email.gmailMessageId} onClick={() => handleSelectEmail(email)}
                    className={`p-4 cursor-pointer border-l-4 ${selectedEmailId === email.gmailMessageId ? 'bg-slate-100 border-primary' : 'border-transparent hover:bg-slate-50'}`}>
                    <div className="flex justify-between items-center text-sm mb-1">
                      <p className="font-bold truncate">{email.from.split('<')[0].trim()}</p>
                      <PriorityBadge priority={email.aiPriority} />
                    </div>
                    <p className="font-semibold text-slate-800 truncate">{email.subject}</p>
                    <p className="text-sm text-muted-foreground truncate">{email.snippet}</p>
                  </div>
                ))}
              </div>
          </div>
          {user && <UserProfileCard user={user} onLogout={handleLogout} />}
        </aside>
        <main className="flex-1 overflow-y-auto p-6 bg-slate-100">
          {!selectedEmail ? (<div className="flex items-center justify-center h-full text-muted-foreground">Select an email to view details.</div>)
          : (
            <Card className="max-w-4xl mx-auto">
              <CardHeader>
                <div className="flex items-start justify-between">
                    <div>
                        <CardTitle className="text-2xl">{selectedEmail.subject}</CardTitle>
                        <div className="flex items-center space-x-2 text-muted-foreground mt-2">
                            <Avatar className="h-8 w-8"><AvatarFallback>{selectedEmail.from.charAt(0).toUpperCase()}</AvatarFallback></Avatar>
                            <span>{selectedEmail.from}</span>
                        </div>
                    </div>
                    <Badge variant="outline">{new Date(selectedEmail.receivedAt).toLocaleString()}</Badge>
                </div>
              </CardHeader>
              <CardContent>
                <Separator className="my-4" />
                <div className="bg-slate-50 p-4 rounded-lg border">
                  <h3 className="font-semibold mb-2">AI Analysis</h3>
                  <p className="text-sm italic text-slate-700">"{selectedEmail.aiSummary}"</p>
                </div>
                <Separator className="my-4" />
                <div className="space-y-4">
                  <Card>
                    <CardHeader><CardTitle className="text-lg flex items-center"><Send className="mr-2 h-5 w-5" /> Send Reply</CardTitle></CardHeader>
                    <CardContent>
                      <Textarea value={replyContent} onChange={(e) => setReplyContent(e.target.value)} rows={6} className="font-mono text-sm" placeholder="AI suggestion will appear here..."/>
                      <div className="flex justify-end mt-2">
                        <Button onClick={handleSendEmail} disabled={isSending}>
                          {isSending ? <Loader className="mr-2 h-4 w-4 animate-spin"/> : <Send className="mr-2 h-4 w-4" />}
                          {isSending ? 'Sending...' : 'Send'}
                        </Button>
                      </div>
                    </CardContent>
                  </Card>
                  {selectedEmail.isMeetingRequest && <CalendarAssistant email={selectedEmail} />}
                </div>
                <Separator className="my-4" />
                <div className="border-t pt-4">
                  <h3 className="font-semibold mb-2">Original Email</h3>
                  <div className="prose max-w-none prose-sm"
                    dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(selectedEmail.body || '') }} />
                </div>
              </CardContent>
            </Card>
          )}
        </main>
      </div>
    </div>
  );
}